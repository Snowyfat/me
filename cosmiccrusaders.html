<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Crusaders</title>
    <style>
        /* Ensures no external CSS file is needed */
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: #111; font-family: Arial, sans-serif; color: white; overflow: hidden; }
        canvas { border: 1px solid #444; background-color: black; display: block; }
        #controls-info { position: absolute; top: 10px; left: 10px; font-size: 12px; color: #aaa; opacity: 0.7; }
        #error-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.8); color: red; font-size: 16px; padding: 20px; display: none; flex-direction: column; justify-content: center; align-items: center; z-index: 100; white-space: pre-wrap; overflow-y: auto; box-sizing: border-box; text-align: center; }
        #error-overlay h2 { margin-top: 0; }
        #error-overlay pre { background-color: #222; padding: 10px; border-radius: 5px; text-align: left; max-height: 60vh; overflow-y: auto; }
        #error-overlay button { margin-top: 15px; padding: 8px 15px; cursor: pointer; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="controls-info"> Controls: Arrows/A/D = Move, Space = Shoot, C = Nova, P = Pause, ESC = Pause/Quit Menu </div>
    <div id="error-overlay">
        <h2>An Error Occurred!</h2>
        <p>Check the browser's developer console (F12) for details.</p>
        <pre id="error-message"></pre>
        <button onclick="location.reload()">Reload Game</button>
    </div>

    <script>
        'use strict';

        // --- Error Handling Setup ---
        const errorOverlay = document.getElementById('error-overlay');
        const errorMessagePre = document.getElementById('error-message');
        let isLoopRunning = true;

        function showFatalError(message, errorObject = null) { /* ... Same error handling function ... */
            console.error("FATAL ERROR:", message, errorObject);
            isLoopRunning = false;
            errorMessagePre.textContent = message + (errorObject ? `\n\n${errorObject.stack || errorObject}` : '');
            errorOverlay.style.display = 'flex';
        }
        window.onerror = function (message, source, lineno, colno, error) { if (isLoopRunning) { showFatalError(`Unhandled error: ${message}\nSource: ${source}:${lineno}`, error); } return true; };
        window.onunhandledrejection = function(event) { if (isLoopRunning) { showFatalError("Unhandled promise rejection:", event.reason); } };

        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        let ctx = null; // Initialize as null
        try {
             ctx = canvas.getContext('2d');
             if (!ctx) {
                 throw new Error("Could not get 2D context from canvas.");
             }
        } catch (e) {
             showFatalError("Canvas/Context Initialization Error:", e);
             // Stop script execution if canvas fails fundamentally
             throw new Error("Cannot proceed without canvas context.");
        }


        const WIDTH = 800; const HEIGHT = 600;
        canvas.width = WIDTH; canvas.height = HEIGHT;

        // --- Game Constants ---
        const FPS = 60; const PLAYER_SPEED = 350; const PLAYER_SHOOT_DELAY = 250;
        const PLAYER_BULLET_SPEED = 600; const PLAYER_LIVES = 3; const PLAYER_INVULN_DURATION = 2000;
        const PLAYER_NOVA_CHARGE_TIME = 1500; const PLAYER_NOVA_COOLDOWN = 10000; const PLAYER_NOVA_RADIUS = 150;
        const ENEMY_BULLET_SPEED = 250; const ENEMY_SHOOT_CHANCE_BASE = 0.0008; const ENEMY_MOVE_DOWN_STEP = 10;
        const ENEMY_DIVE_SPEED = 300; const ENEMY_CHARGE_SPEED = 350; const ENEMY_BEAM_CHARGE_TIME = 1000;
        const ENEMY_BEAM_DURATION = 500; const ENEMY_BEAM_WIDTH = 10; const ENEMY_FLEET_MOVE_INTERVAL_BASE = 700;
        const ENEMY_FLEET_STEP_X_BASE = 8; const POWERUP_DROP_CHANCE_BASE = 0.08; const POWERUP_DURATION = 7000;
        const POWERUP_SPEED = 150; const PARTICLE_COUNT = 15; const PARTICLE_SPEED_MAX = 180; const PARTICLE_LIFESPAN = 0.4;
        const COLORS = { WHITE: 'white', BLACK: 'black', RED: 'red', GREEN: 'lime', BLUE: 'blue', YELLOW: 'yellow', CYAN: 'cyan', MAGENTA: 'magenta', ORANGE: 'orange', PURPLE: 'purple', LIGHTBLUE: 'lightblue', GRAY: '#888' };

        // --- Game State ---
        let score = 0; let wave = 0; let gameState = 'START'; let player = null;
        let enemies = []; let playerBullets = []; let enemyBullets = []; let powerups = []; let particles = [];
        let starfield = null;
        let enemyFleetMoveTimer = 0; let enemyFleetMoveInterval = ENEMY_FLEET_MOVE_INTERVAL_BASE;
        let enemyFleetNeedsDownMove = false; let enemyMoveDirection = 1; let enemyFleetSpeedFactor = 1.0;
        let enemiesSpawnedThisWave = 0;
        const keysDown = {};
        let lastTime = 0; let gameTime = 0;

        // --- Input Listeners ---
        window.addEventListener('keydown', (e) => { keysDown[e.key.toLowerCase()] = true; if ([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) e.preventDefault(); });
        window.addEventListener('keyup', (e) => { keysDown[e.key.toLowerCase()] = false; });

        // --- Helper Functions ---
        function randomRange(min, max) { return Math.random() * (max - min) + min; }
        function rectOverlap(rect1, rect2) { if (!rect1 || !rect2) return false; return (rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x && rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y); }
        function drawText(text, x, y, size = 18, color = COLORS.WHITE, align = 'left', font = 'Arial') { if (!ctx) return; try { ctx.fillStyle = color; ctx.font = `${size}px ${font}`; ctx.textAlign = align; ctx.textBaseline = 'top'; ctx.fillText(text, x, y); } catch(e){ console.error("Error drawing text:", text, e); } }

        // --- Game Classes ---
        class Player { /* ... Full Player class code ... */
             constructor() { this.width = 40; this.height = 30; this.x = WIDTH / 2 - this.width / 2; this.y = HEIGHT - this.height - 10; this.speed = PLAYER_SPEED; this.lives = PLAYER_LIVES; this.shootTimer = 0; this.shootDelay = PLAYER_SHOOT_DELAY; this.powerupType = null; this.powerupTimer = 0; this.invulnerable = false; this.invulnTimer = 0; this.novaCharging = false; this.novaChargeTimer = 0; this.novaReady = true; this.novaCooldownTimer = 0; this.hidden = false; this.hideTimer = 0; this.color = COLORS.GREEN; }
             update(dt) { const now = gameTime; if (this.hidden && now > this.hideTimer + PLAYER_INVULN_DURATION) { this.hidden = false; this.invulnerable = true; this.invulnTimer = now + PLAYER_INVULN_DURATION; this.x = WIDTH / 2 - this.width / 2; this.y = HEIGHT - this.height - 10; } if (this.invulnerable && now > this.invulnTimer) { this.invulnerable = false; if (this.powerupType === 'shield') this.endPowerup('shield'); } if (this.powerupType && this.powerupType !== 'shield' && now > this.powerupTimer + POWERUP_DURATION) { this.endPowerup(this.powerupType); } if (this.hidden) return; let moveX = 0; if (keysDown['arrowleft'] || keysDown['a']) moveX -= 1; if (keysDown['arrowright'] || keysDown['d']) moveX += 1; this.x += moveX * this.speed * dt; this.x = Math.max(0, Math.min(WIDTH - this.width, this.x)); this.shootTimer -= dt * 1000; if (keysDown[' '] && this.shootTimer <= 0) { this.shoot(); this.shootTimer = this.shootDelay; } if (keysDown['c'] && this.novaReady && !this.novaCharging) { this.novaCharging = true; this.novaChargeTimer = 0; } else if (!keysDown['c'] && this.novaCharging) { this.novaCharging = false; } if (this.novaCharging) { this.novaChargeTimer += dt * 1000; if (this.novaChargeTimer >= PLAYER_NOVA_CHARGE_TIME) { this.activateNovaBurst(); this.novaCharging = false; } } if (!this.novaReady) { this.novaCooldownTimer -= dt * 1000; if (this.novaCooldownTimer <= 0) { this.novaReady = true; } } }
             draw(ctx) { if (this.hidden || !ctx) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); if (this.invulnerable) { const pulse = Math.abs(Math.sin(gameTime * 0.005)); ctx.strokeStyle = `rgba(0, 0, 255, ${0.5 + pulse * 0.4})`; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2 + 5, 0, Math.PI * 2); ctx.stroke(); } if (this.novaCharging) { const chargePct = Math.min(1.0, this.novaChargeTimer / PLAYER_NOVA_CHARGE_TIME); const r = Math.floor(255 * (1 - chargePct)); const g = Math.floor(255 * chargePct); ctx.strokeStyle = `rgb(${r},${g},0)`; ctx.lineWidth = 2; ctx.beginPath(); const radius = (this.width * 0.4 * chargePct) + 2; ctx.arc(this.x + this.width / 2, this.y + this.height / 2 - 5, radius, 0, Math.PI * 2); ctx.stroke(); } }
             shoot() { const bx = this.x + this.width / 2; const by = this.y; if (this.powerupType === 'spread') { playerBullets.push(new Bullet(bx - 10, by, -PLAYER_BULLET_SPEED, -7)); playerBullets.push(new Bullet(bx, by, -PLAYER_BULLET_SPEED, 0)); playerBullets.push(new Bullet(bx + 10, by, -PLAYER_BULLET_SPEED, 7)); } else { playerBullets.push(new Bullet(bx, by, -PLAYER_BULLET_SPEED, 0)); } }
             activatePowerup(type) { const now = gameTime; if (this.powerupType && this.powerupType !== type) this.endPowerup(this.powerupType); this.powerupType = type; this.powerupTimer = now; if (type === 'rapid') this.shootDelay = PLAYER_SHOOT_DELAY / 2; if (type === 'shield') { this.invulnerable = true; this.invulnTimer = now + POWERUP_DURATION; } }
             endPowerup(typeEnding) { if (typeEnding === 'rapid' && this.powerupType === 'rapid') this.shootDelay = PLAYER_SHOOT_DELAY; if (this.powerupType === typeEnding) this.powerupType = null; }
             activateNovaBurst() { if (!this.novaReady) return; createExplosion(this.x + this.width / 2, this.y + this.height / 2, 'large', 1.0, 'nova'); let killed = 0; enemyBullets = enemyBullets.filter(bullet => { const dx = bullet.x - (this.x + this.width / 2); const dy = bullet.y - (this.y + this.height / 2); const distSq = dx * dx + dy * dy; if (distSq < PLAYER_NOVA_RADIUS * PLAYER_NOVA_RADIUS) { createExplosion(bullet.x, bullet.y, 'tiny'); killed++; return false; } return true; }); this.novaReady = false; this.novaCooldownTimer = PLAYER_NOVA_COOLDOWN; }
             hit() { if (this.invulnerable || this.hidden) return false; this.lives--; this.hide(); createExplosion(this.x + this.width / 2, this.y + this.height / 2, 'large'); if (this.powerupType) this.endPowerup(this.powerupType); return true; }
             hide() { this.hidden = true; this.hideTimer = gameTime; this.invulnerable = false; this.novaCharging = false; }
             reset() { this.x = WIDTH / 2 - this.width / 2; this.y = HEIGHT - this.height - 10; this.lives = PLAYER_LIVES; this.powerupType = null; this.invulnerable = false; this.novaReady = true; this.hidden = false; this.shootDelay = PLAYER_SHOOT_DELAY; }
             getHitbox() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
        }
        class Enemy { /* ... Full Enemy class code ... */
             constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.state = 'formation'; this.lastStateChange = gameTime + randomRange(-1000, 1000); this.speedX = 0; this.speedY = 0; this.beamChargeTimer = 0; this.beamFireTimer = 0; this.beamActive = false; switch (type) { case 'grunt': this.width = 30; this.height = 20; this.color = COLORS.RED; break; case 'diver': this.width = 35; this.height = 25; this.color = COLORS.ORANGE; this.shape = 'triangle'; break; case 'charger': this.width = 40; this.height = 20; this.color = COLORS.MAGENTA; break; case 'beamer': this.width = 30; this.height = 30; this.color = COLORS.PURPLE; this.shape = 'circle'; break; default: this.width = 30; this.height = 20; this.color = COLORS.RED; } this.baseColor = this.color; this.isActive = true; }
             update(dt) { const now = gameTime; if (this.state === 'formation') { this.x += this.speedX * dt; this._behaviorFormation(dt, now); } else if (this.state === 'diving') { this._behaviorDiving(dt, now); } else if (this.state === 'ramming') { this._behaviorRamming(dt, now); } else if (this.state === 'charging_beam') { this._behaviorChargingBeam(dt, now); } else if (this.state === 'firing_beam') { this._behaviorFiringBeam(dt, now); } this.y += this.speedY * dt; if ((this.state === 'diving' || this.state === 'ramming') && this.y > HEIGHT) { this.isActive = false; } if (this.state !== 'firing_beam') { this.beamActive = false; } if (this.state !== 'charging_beam') { this.color = this.baseColor; } }
             _behaviorFormation(dt, now) { const numEnemies = enemies.length; const shootModifier = enemiesSpawnedThisWave > 0 ? Math.max(0.1, numEnemies / enemiesSpawnedThisWave) : 1.0; const waveBonus = wave * 0.0001; const dynamicChance = (ENEMY_SHOOT_CHANCE_BASE + waveBonus) * shootModifier; if (Math.random() < dynamicChance) { this.shoot(); } const timeSinceChange = now - this.lastStateChange; const diverDelay = Math.max(2000, randomRange(5000, 15000) - (wave * 100)); const chargerDelay = Math.max(3000, randomRange(6000, 12000) - (wave * 100)); const beamerDelay = Math.max(4000, randomRange(8000, 20000) - (wave * 150)); const canDive = this.y + this.height < HEIGHT * 0.75; if (this.type === 'diver' && canDive && timeSinceChange > diverDelay) { this.state = 'diving'; this.speedX = randomRange(-1, 1) * 100; this.speedY = ENEMY_DIVE_SPEED + (wave * 10); this.lastStateChange = now; } else if (this.type === 'charger' && player && !player.hidden && Math.abs((this.x + this.width / 2) - (player.x + player.width / 2)) < this.width * 1.5 && this.y + this.height < player.y && timeSinceChange > chargerDelay) { this.state = 'ramming'; this.speedX = 0; this.speedY = ENEMY_CHARGE_SPEED + (wave * 15); this.lastStateChange = now; } else if (this.type === 'beamer' && timeSinceChange > beamerDelay) { this.state = 'charging_beam'; this.speedX = 0; this.speedY = 0; this.beamChargeTimer = 0; this.lastStateChange = now; } }
            _behaviorDiving(dt, now) { this.x += this.speedX * dt; } _behaviorRamming(dt, now) { }
             _behaviorChargingBeam(dt, now) { this.beamChargeTimer += dt * 1000; const chargeRatio = Math.min(1.0, this.beamChargeTimer / ENEMY_BEAM_CHARGE_TIME); const r = Math.floor(255 * (1 - chargeRatio)); const g = 255; const b = Math.floor(255 * chargeRatio); this.color = `rgb(${r},${g},${b})`; if (chargeRatio >= 1.0) { this.state = 'firing_beam'; this.beamFireTimer = 0; this.lastStateChange = now; this.beamActive = true; this.color = this.baseColor; } }
             _behaviorFiringBeam(dt, now) { this.beamFireTimer += dt * 1000; const beamDuration = Math.max(200, ENEMY_BEAM_DURATION - (wave * 10)); if (this.beamFireTimer > beamDuration) { this.state = 'formation'; this.speedY = 0; this.lastStateChange = now; this.beamActive = false; } else { this.beamActive = true; } }
             shoot() { let canShoot = false; if (this.state === 'formation') { if (this.type === 'grunt' || this.type === 'beamer') canShoot = true; else if (this.type === 'diver' && Math.random() < 0.1) canShoot = true; } if (canShoot) { const bulletSpeed = ENEMY_BULLET_SPEED + (wave * 10); const spawnX = this.x + this.width / 2 + randomRange(-2, 2); const spawnY = this.y + this.height; enemyBullets.push(new Bullet(spawnX, spawnY, bulletSpeed, 0, COLORS.YELLOW, 6, 12)); } }
             draw(ctx) { if (!ctx) return; ctx.fillStyle = this.color; if (this.shape === 'circle') { ctx.beginPath(); ctx.arc(this.x + this.width / 2, this.y + this.height / 2, this.width / 2, 0, Math.PI * 2); ctx.fill(); } else if (this.shape === 'triangle') { ctx.beginPath(); ctx.moveTo(this.x, this.y + this.height); ctx.lineTo(this.x + this.width / 2, this.y); ctx.lineTo(this.x + this.width, this.y + this.height); ctx.closePath(); ctx.fill(); } else { ctx.fillRect(this.x, this.y, this.width, this.height); } if (this.beamActive) { const beamLength = HEIGHT - (this.y + this.height); if (beamLength > 0) { const alpha = 0.6 + Math.abs(Math.sin(gameTime * 0.05)) * 0.3; ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`; ctx.fillRect(this.x + this.width / 2 - ENEMY_BEAM_WIDTH / 2, this.y + this.height, ENEMY_BEAM_WIDTH, beamLength); } } }
             getHitbox() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
             getBeamHitbox() { if (this.beamActive) { const beamY = this.y + this.height; const beamLength = HEIGHT - beamY; if (beamLength > 0) { return { x: this.x + this.width / 2 - ENEMY_BEAM_WIDTH / 2, y: beamY, width: ENEMY_BEAM_WIDTH, height: beamLength }; } } return null; }
        }
        class Bullet { /* ... Full Bullet class code ... */
             constructor(x, y, speedY, angle = 0, color = COLORS.WHITE, width = 5, height = 10) { this.x = x - width / 2; this.y = y; this.width = width; this.height = height; this.color = color; this.angle = angle * (Math.PI / 180); this.speedY = speedY; this.speedX = Math.sin(this.angle) * Math.abs(speedY) * 0.3; this.isActive = true; }
             update(dt) { this.x += this.speedX * dt; this.y += this.speedY * dt; if (this.y + this.height < 0 || this.y > HEIGHT) { this.isActive = false; } }
             draw(ctx) { if (!ctx) return; ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.width, this.height); }
             getHitbox() { return { x: this.x, y: this.y, width: this.width, height: this.height }; }
        }
        class PowerUp { /* ... Full PowerUp class code ... */
             constructor(x, y, type) { this.x = x; this.y = y; this.type = type; this.speedY = POWERUP_SPEED; this.size = 20; this.isActive = true; switch (type) { case 'shield': this.color = COLORS.BLUE; this.shape = 'circle_border'; break; case 'rapid': this.color = COLORS.YELLOW; this.shape = 'plus'; break; case 'spread': this.color = COLORS.GREEN; this.shape = 'pyramid'; break; default: this.color = COLORS.WHITE; this.shape = 'circle'; } this.x -= this.size / 2; this.y -= this.size / 2; }
             update(dt) { this.y += this.speedY * dt; if (this.y > HEIGHT) { this.isActive = false; } }
             draw(ctx) { if (!ctx) return; const centerX = this.x + this.size / 2; const centerY = this.y + this.size / 2; ctx.fillStyle = this.color; ctx.strokeStyle = this.color; ctx.lineWidth = 2; if (this.shape === 'circle') { ctx.beginPath(); ctx.arc(centerX, centerY, this.size / 2, 0, Math.PI * 2); ctx.fill(); } else if (this.shape === 'circle_border') { ctx.beginPath(); ctx.arc(centerX, centerY, this.size / 2, 0, Math.PI * 2); ctx.stroke(); } else if (this.shape === 'plus') { ctx.beginPath(); ctx.moveTo(centerX, this.y + 2); ctx.lineTo(centerX, this.y + this.size - 2); ctx.moveTo(this.x + 2, centerY); ctx.lineTo(this.x + this.size - 2, centerY); ctx.stroke(); } else if (this.shape === 'pyramid') { ctx.beginPath(); ctx.moveTo(centerX, this.y + 2); ctx.lineTo(this.x + 2, this.y + this.size - 2); ctx.lineTo(this.x + this.size - 2, this.y + this.size - 2); ctx.closePath(); ctx.fill(); } }
             getHitbox() { return { x: this.x, y: this.y, width: this.size, height: this.size }; }
        }
        class Particle { /* ... Full Particle class code ... */
             constructor(x, y, sizeFactor = 1.0, colorSet = PARTICLE_COLORS) { this.x = x; this.y = y; this.size = Math.max(1, randomRange(2, 5) * sizeFactor); const angle = randomRange(0, Math.PI * 2); const speed = randomRange(PARTICLE_SPEED_MAX * 0.2, PARTICLE_SPEED_MAX) * sizeFactor * 0.6; this.speedX = Math.cos(angle) * speed; this.speedY = Math.sin(angle) * speed; this.lifespan = PARTICLE_LIFESPAN * Math.sqrt(sizeFactor) * randomRange(0.8, 1.2); this.initialLifespan = this.lifespan; this.color = colorSet[Math.floor(Math.random() * colorSet.length)]; this.isActive = true; }
             update(dt) { this.x += this.speedX * dt; this.y += this.speedY * dt; this.lifespan -= dt; if (this.lifespan <= 0) { this.isActive = false; } }
             draw(ctx) { if (!ctx) return; const alpha = Math.max(0, this.lifespan / this.initialLifespan); ctx.globalAlpha = alpha; ctx.fillStyle = this.color; ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size); ctx.globalAlpha = 1.0; }
        }
        class Starfield { /* ... Full Starfield class code ... */
             constructor(numStars = 150) { this.stars = []; for (let i = 0; i < numStars; i++) { this.stars.push({ x: Math.random() * WIDTH, y: Math.random() * HEIGHT, speed: randomRange(1, 3), size: 0, color: '' }); } }
             update(dt) { this.stars.forEach(star => { star.y += star.speed; if (star.y > HEIGHT) { star.y = randomRange(-20, -5); star.x = Math.random() * WIDTH; } }); }
             draw(ctx) { if (!ctx) return; this.stars.forEach(star => { const brightness = Math.floor(50 + star.speed * 40); star.color = `rgb(${brightness},${brightness},${brightness})`; star.size = Math.max(1, Math.floor(star.speed / 2) + 1); if (star.size > 1) { ctx.fillStyle = star.color; ctx.fillRect(star.x - star.size/2, star.y - star.size/2, star.size, star.size); } else { ctx.fillStyle = star.color; ctx.fillRect(star.x, star.y, 1, 1); } }); }
        }


        // --- Game Logic Functions ---
        function initializeGame() { /* ... Includes try-catch ... */
            console.log("Attempting to initialize game state...");
            try {
                score = 0; wave = 0; enemies = []; playerBullets = []; enemyBullets = []; powerups = []; particles = [];
                if (!starfield) { starfield = new Starfield(); console.log("Starfield created."); }
                player = new Player(); console.log("Player created.");
                enemyFleetMoveTimer = 0; enemyFleetMoveInterval = ENEMY_FLEET_MOVE_INTERVAL_BASE; enemyFleetNeedsDownMove = false; enemyMoveDirection = 1; enemyFleetSpeedFactor = 1.0; enemiesSpawnedThisWave = 0;
                nextWave();
                gameState = 'PLAYING'; console.log("Game state initialized successfully. State set to PLAYING.");
            } catch (error) { showFatalError("Error during game initialization:", error); }
         }
        function nextWave() { /* ... Includes try-catch ... */
            console.log(`Attempting to start Wave ${wave + 1}`);
             try {
                wave++; enemies = []; playerBullets = []; enemyBullets = []; powerups = [];
                enemyFleetMoveInterval = Math.max(150, ENEMY_FLEET_MOVE_INTERVAL_BASE - wave * 20); enemyFleetSpeedFactor = 1.0 + wave * 0.06;
                const rows = Math.min(5, 2 + Math.floor(wave / 3)); const cols = Math.min(10, 5 + Math.floor(wave / 2)); const spawnWidth = cols * 45; const startX = Math.max(10, (WIDTH - spawnWidth) / 2); const startY = 60; enemiesSpawnedThisWave = 0;
                for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { const x = startX + c * 45; const y = startY + r * 40; let type = 'grunt'; const roll = Math.random(); const bChance = wave >= 4 ? 0.10 + wave * 0.015 : 0; const cChance = wave >= 3 ? 0.10 + wave * 0.015 : 0; const dChance = wave >= 2 ? 0.10 + wave * 0.01 : 0; if (roll < bChance) type = 'beamer'; else if (roll < bChance + cChance) type = 'charger'; else if (roll < bChance + cChance + dChance) type = 'diver'; enemies.push(new Enemy(x, y, type)); enemiesSpawnedThisWave++; } }
                console.log(`Wave ${wave} spawned ${enemiesSpawnedThisWave} enemies.`);
             } catch (error) { showFatalError(`Error during nextWave (Wave ${wave+1}):`, error); }
        }
        function createExplosion(x, y, size = 'medium', countMult = 1.0, effect = null) { /* ... Includes try-catch ... */
             try { let num = Math.floor(PARTICLE_COUNT * countMult); let factor = { tiny: 0.5, small: 0.7, medium: 1.0, large: 1.5, nova: 2.5 }[size] || 1.0; let colors = PARTICLE_COLORS; if (effect === 'nova') { num = 75; colors = [COLORS.CYAN, COLORS.WHITE, COLORS.BLUE, COLORS.LIGHTBLUE]; } for (let i = 0; i < num; i++) { particles.push(new Particle(x, y, factor, colors)); } } catch (error) { console.error("Error creating explosion:", error); }
         }
        function updateGame(dt) { /* ... Includes try-catch ... */
             try { if (!player) { console.error("UpdateGame called but player is null!"); gameState = 'START'; return; } player.update(dt); playerBullets.forEach(b => b.update(dt)); enemyBullets.forEach(b => b.update(dt)); powerups.forEach(p => p.update(dt)); particles.forEach(p => p.update(dt)); enemyFleetMoveTimer += dt * 1000; let moveFleetThisFrame = false; if (enemyFleetMoveTimer >= enemyFleetMoveInterval) { moveFleetThisFrame = true; enemyFleetMoveTimer = 0; } let moveDown = false, moveSide = false, edgeHit = false; if (moveFleetThisFrame) { moveDown = enemyFleetNeedsDownMove; moveSide = !moveDown; if (moveDown) enemyFleetNeedsDownMove = false; } const stepX = ENEMY_FLEET_STEP_X_BASE * enemyFleetSpeedFactor * enemyMoveDirection; enemies.forEach(enemy => { if (enemy.state === 'formation') { if (moveDown) { enemy.y += ENEMY_MOVE_DOWN_STEP; enemy.speedX = 0; } else if (moveSide) { enemy.speedX = stepX / dt; const nextX = enemy.x + stepX; if ((nextX + enemy.width > WIDTH - 10 && enemyMoveDirection === 1) || (nextX < 10 && enemyMoveDirection === -1)) { edgeHit = true; } } else { enemy.speedX = 0; } enemy.speedY = 0; } enemy.update(dt); }); if (edgeHit) { enemyMoveDirection *= -1; enemyFleetNeedsDownMove = true; enemyFleetMoveInterval = Math.max(50, enemyFleetMoveInterval * 0.97); } const playerHitbox = player.getHitbox(); playerBullets.forEach(bullet => { if (!bullet.isActive) return; enemies.forEach(enemy => { if (!enemy.isActive) return; if (rectOverlap(bullet.getHitbox(), enemy.getHitbox())) { bullet.isActive = false; enemy.isActive = false; score += ({grunt: 10, diver: 15, charger: 20, beamer: 25}[enemy.type] || 5) + Math.floor(wave / 2); createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, enemy.type === 'grunt' ? 'small' : 'medium'); if (Math.random() < POWERUP_DROP_CHANCE_BASE + (wave * 0.005)) { powerups.push(new PowerUp(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, randomRange(0,1) < 0.33 ? 'shield' : (randomRange(0,1)<0.5 ? 'rapid' : 'spread') )); } } }); }); powerups.forEach(powerup => { if (!powerup.isActive) return; if (rectOverlap(playerHitbox, powerup.getHitbox())) { player.activatePowerup(powerup.type); powerup.isActive = false; } }); if (!player.hidden) { if (!player.invulnerable) { enemyBullets.forEach(bullet => { if (!bullet.isActive) return; if (rectOverlap(playerHitbox, bullet.getHitbox())) { bullet.isActive = false; if (player.hit() && player.lives <= 0) { gameState = 'GAME_OVER'; return; } } }); } if (!player.invulnerable) { enemies.forEach(enemy => { if (!enemy.isActive || enemy.type !== 'beamer') return; const beamHitbox = enemy.getBeamHitbox(); if (beamHitbox && rectOverlap(playerHitbox, beamHitbox)) { if (player.hit() && player.lives <= 0) { gameState = 'GAME_OVER'; return; } } }); } if (!player.invulnerable) { enemies.forEach(enemy => { if (!enemy.isActive) return; const isDangerous = (enemy.state === 'diving' || enemy.state === 'ramming') || (enemy.state === 'formation' && rectOverlap(playerHitbox, enemy.getHitbox())); if (isDangerous && rectOverlap(playerHitbox, enemy.getHitbox())) { createExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2, 'small'); enemy.isActive = false; if (player.hit() && player.lives <= 0) { gameState = 'GAME_OVER'; return; } } }); } } playerBullets = playerBullets.filter(b => b.isActive); enemyBullets = enemyBullets.filter(b => b.isActive); enemies = enemies.filter(e => e.isActive); powerups = powerups.filter(p => p.isActive); particles = particles.filter(p => p.isActive); if (enemies.length === 0 && enemiesSpawnedThisWave > 0) { console.log(`Wave ${wave} cleared!`); enemiesSpawnedThisWave = 0; score += wave * 50; nextWave(); } let lowestEnemyY = 0; enemies.forEach(enemy => { if (enemy.state === 'formation') lowestEnemyY = Math.max(lowestEnemyY, enemy.y + enemy.height); }); if (lowestEnemyY >= HEIGHT - 60) { console.log("Game Over: Fleet reached bottom."); gameState = 'GAME_OVER'; } } catch (error) { showFatalError("Error during game update:", error); }
         }
        function drawGame() { /* ... Includes the fix for drawing lives ... */
            try { if (!ctx) { console.error("drawGame: ctx is null!"); return; } if (!starfield) { console.error("drawGame: starfield is null!"); ctx.fillStyle='black'; ctx.fillRect(0,0,WIDTH,HEIGHT); return; } if (!player) { console.error("drawGame: player is null!"); ctx.fillStyle='black'; ctx.fillRect(0,0,WIDTH,HEIGHT); return; } starfield.draw(ctx); powerups.forEach(p => p.draw(ctx)); playerBullets.forEach(b => b.draw(ctx)); enemyBullets.forEach(b => b.draw(ctx)); enemies.forEach(e => e.draw(ctx)); particles.forEach(p => p.draw(ctx)); player.draw(ctx); drawText(`Score: ${score}`, WIDTH / 2, 5, 18, COLORS.WHITE, 'center'); drawText(`Wave: ${wave}`, WIDTH - 10, 5, 18, COLORS.WHITE, 'right');
                // --- CORRECTED LIVES DRAWING ---
                const lifeIconWidth = 40 * 0.5; const lifeIconHeight = 30 * 0.5; const lifeIconColor = COLORS.GREEN;
                for (let i = 0; i < player.lives; i++) { ctx.fillStyle = lifeIconColor; ctx.fillRect(10 + i * (lifeIconWidth + 5), 5, lifeIconWidth, lifeIconHeight); }
                // --- END CORRECTION ---
                 if (player.powerupType) { const now = gameTime; let duration = POWERUP_DURATION; let startTime = player.powerupTimer; let remaining = 0; if (player.powerupType === 'shield') { remaining = Math.max(0, player.invulnTimer - now); } else { remaining = Math.max(0, (startTime + duration) - now); } const pct = duration > 0 ? remaining / duration : 0; const barLength = 100; const barHeight = 10; const fill = pct * barLength; const barX = 10; const barY = HEIGHT - barHeight - 5; const powerColor = {rapid: COLORS.YELLOW, shield: COLORS.BLUE, spread: COLORS.GREEN}[player.powerupType] || COLORS.WHITE; ctx.fillStyle = powerColor; ctx.fillRect(barX, barY, fill, barHeight); ctx.strokeStyle = COLORS.WHITE; ctx.lineWidth = 2; ctx.strokeRect(barX, barY, barLength, barHeight); drawText(player.powerupType.toUpperCase(), barX + barLength + 5, barY - 2, 12); } const novaColor = player.novaReady ? COLORS.GREEN : (player.novaCharging ? COLORS.YELLOW : COLORS.RED); const novaText = player.novaReady ? "Nova READY" : (player.novaCharging ? "Charging" : "Recharging"); drawText(novaText, WIDTH - 10, HEIGHT - 20, 14, novaColor, 'right'); } catch (error) { showFatalError("Error during game drawing:", error); }
         }
        function updateStartScreen(dt) { /* ... Includes try-catch ... */
             try { if (starfield) starfield.update(dt); for (const key in keysDown) { if (keysDown[key] && !['shift', 'control', 'alt', 'meta'].includes(key)) { console.log("Key pressed on start screen, initializing game..."); initializeGame(); keysDown[key] = false; break; } } } catch (error) { showFatalError("Error during start screen update:", error); }
         }
        function drawStartScreen() { /* ... Includes try-catch ... */
             try { if (starfield) starfield.draw(ctx); else { ctx.fillStyle = 'black'; ctx.fillRect(0, 0, WIDTH, HEIGHT); } drawText("COSMIC CRUSADERS", WIDTH / 2, HEIGHT * 0.20, 58, COLORS.CYAN, 'center'); drawText("Arrows / A/D: Move", WIDTH / 2, HEIGHT * 0.45, 22, COLORS.WHITE, 'center'); drawText("Space: Shoot", WIDTH / 2, HEIGHT * 0.50, 22, COLORS.WHITE, 'center'); drawText("Hold C: Nova Burst", WIDTH / 2, HEIGHT * 0.57, 20, COLORS.YELLOW, 'center'); drawText("P: Pause / ESC: Pause/Quit Menu", WIDTH / 2, HEIGHT * 0.62, 20, COLORS.WHITE, 'center'); drawText("Press Any Key to Begin", WIDTH / 2, HEIGHT * 0.80, 24, COLORS.GREEN, 'center'); } catch (error) { showFatalError("Error during start screen drawing:", error); }
         }
        function updateGameOverScreen(dt) { /* ... Includes try-catch ... */
             try { if(starfield) starfield.update(dt); for (const key in keysDown) { if (keysDown[key]) { if (key === 'escape') { isLoopRunning = false; console.log("Quit via ESC on Game Over."); } else if (!['shift', 'control', 'alt', 'meta'].includes(key)) { gameState = 'START'; for(let k in keysDown) keysDown[k] = false; } break; } } } catch (e) { showFatalError("Error in updateGameOverScreen", e); }
         }
        function drawGameOverScreen() { /* ... Includes try-catch ... */
             try { if(starfield) starfield.draw(ctx); else { ctx.fillStyle = 'black'; ctx.fillRect(0, 0, WIDTH, HEIGHT); } drawText("GAME OVER", WIDTH / 2, HEIGHT / 4, 64, COLORS.RED, 'center'); drawText(`Final Score: ${score}`, WIDTH / 2, HEIGHT / 2 - 20, 30, COLORS.WHITE, 'center'); drawText(`Survived ${wave} waves`, WIDTH / 2, HEIGHT / 2 + 20, 22, COLORS.WHITE, 'center'); drawText("Press Any Key to Return to Title", WIDTH / 2, HEIGHT * 0.75, 20, COLORS.GREEN, 'center'); drawText("Press ESC to Quit (Stop Loop)", WIDTH / 2, HEIGHT * 0.80, 18, COLORS.WHITE, 'center'); } catch (e) { showFatalError("Error in drawGameOverScreen", e); }
         }
        function drawPausedScreen() { /* ... Includes try-catch ... */
             try { ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; ctx.fillRect(0, 0, WIDTH, HEIGHT); drawText("PAUSED", WIDTH / 2, HEIGHT / 3, 64, COLORS.YELLOW, 'center'); drawText("Press P to Resume", WIDTH / 2, HEIGHT / 2, 22, COLORS.WHITE, 'center'); drawText("Press ESC to Quit to Title", WIDTH / 2, HEIGHT / 2 + 40, 20, COLORS.WHITE, 'center'); } catch (e) { showFatalError("Error in drawPausedScreen", e); }
         }

        // --- Main Game Loop (Wrapped in try-catch) ---
        function gameLoop(currentTime) { /* ... Same as previous fix ... */
            if (!isLoopRunning) return;
            try {
                const dt = Math.min(0.1, (currentTime - lastTime) / 1000); lastTime = currentTime; gameTime += dt * 1000;
                if (!ctx) { showFatalError("Canvas context is missing in game loop!"); return; }
                ctx.clearRect(0, 0, WIDTH, HEIGHT);
                if (keysDown['p']) { if (gameState === 'PLAYING') gameState = 'PAUSED'; else if (gameState === 'PAUSED') gameState = 'PLAYING'; keysDown['p'] = false; }
                if (keysDown['escape']) { if (gameState === 'PLAYING') gameState = 'PAUSED'; else if (gameState === 'PAUSED') { gameState = 'START'; for(let k in keysDown) keysDown[k] = false; } keysDown['escape'] = false; }
                switch (gameState) {
                    case 'START': updateStartScreen(dt); drawStartScreen(); break;
                    case 'PLAYING': updateGame(dt); drawGame(); break;
                    case 'PAUSED': drawGame(); drawPausedScreen(); break;
                    case 'GAME_OVER': updateGameOverScreen(dt); drawGameOverScreen(); break;
                }
                requestAnimationFrame(gameLoop);
            } catch (error) { showFatalError("Error in main game loop:", error); }
        }

        // --- Start the Game (Wrapped in try-catch) ---
        try {
            console.log("Setting up initial state...");
            if (!ctx) throw new Error("Canvas context not available at startup."); // Check ctx before starfield
            starfield = new Starfield();
            lastTime = performance.now();
            console.log("Requesting first animation frame...");
            requestAnimationFrame(gameLoop);
            console.log("Game loop requested.");
        } catch (error) { showFatalError("Error during initial setup before game loop:", error); }

    </script>
</body>
</html>
